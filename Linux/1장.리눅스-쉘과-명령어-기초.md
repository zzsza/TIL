# 1장. 리눅스 쉘과 명령어 기초
## 리눅스와 쉘
- 쉘(Shell) : 운영체제에서 제공하는 명령을 실행하는 프로그램이며 운영체제의 관리하에 있는 파일, 프린팅, 하드웨어 장치, 애플리케이션과의 인터페이스를 제공한다
- 즉, 운영 체제에서 제공하는 각종 명령들을 쉘 인터페이스에서 실행하면 운영체제가 그 명령에 해당하는 일을 수행
- 쉘 스크립트 : 인터프리터로서 리눅스 시스템에서 지원하는 명령어들의 집합을 묶어서 프로그램화한 것

```
du -h * | sort -nr > $HOME/script.txt
```
- du : 용량을 알아보기 위한 명령어
- ```|``` : 결과값을 다음 명령으로 연결해 다음 명령의 아규먼트로 사용
- sort : 알파벳 또는 숫자 기준으로 정렬. -n : 숫자값을 기준으로 정렬, -r : 반대의 순서(내림차순)
- ```>``` : 리다이렉션은 앞의 명령 결과를 다음에 나오는 파일명으로 저장

- 리눅스 bash 쉘에서 ```$``` 표시는 일반유저의 쉘을 의미하고 ```#``` 표시는 root 유저의 쉘을 의미함


- 쉘 스크립트를 작성할 때 스크립트의 최상단에 본 쉘인 경우 ```#!/bin/sh```, 배시 쉘인 경우 ```#!/bin/bash```, 파이썬일 경우 ```#!/bin/python``` 와 같이 실행할 언어를 지정해야 한다

- ```which 명령어```는 환경 변수에 지정된 PATH 변수의 경로 내에서 실행 파일의 이름을 검색하고자 할 때 사용
- ```whereis```는 명령의 실행 파일, 소스, 맨페이지의 위치를 검색하는 명령


## 리눅스 환경
- 리눅스는 핀란드 헬싱키 대학의 학생이었던 리누스 토발즈의 취미 생활로 탄생

### 리눅스의 특징
- Free
	- OS 구입에 따른 비용을 지출하지 않아도 됨 
- Unix Like
	- 유닉스처럼 리눅스는 C 언어로 작성됨
	- 유닉스처럼 리눅스는 멀티유저/멀티태스킹을 지원하는 네트워크 OS
	- 유닉스처럼 리눅스는 프로그래밍 개발환경에 매우 적합
	- 유닉스처럼 다양한 하드웨어 플랫폼을 지원
		- Intel x86 processor
		- Macintosh PC
		- Cyrix processor
		- AMD processor
		- Sun Microsystems Sparc processor
		- Alpha Processor(Compaq)
- Open Source
- 그 외에 안정성, 강건성, 보안성, 높은 성능 등의 특징도 존재

### 리눅스 파일 시스템
- 리눅스에서 최상위(root) 디렉터리는 ```/```로 표시하고 그 하위에 ```/root```, ```/usr```, ```/etc```, ```/boot```, ```/tmp``` 등으로 구분하며, 각 디렉터리들은 파티션으로 구성될 수 있음. 하나의 파티션이 하나의 디렉터리가 될 수 있음
- 파티션을 디렉터리에 매칭시키기 위해서 ```mount```라는 개념을 사용
- ```/dev``` 디렉터리는 여러 가지 디바이스 관련 파일이 있는 디렉터리
- ```/dev/null``` 파일은 어떤 문자를 이 장치로 보내면 문자를 모두 지워버림
- ```/dev/zero``` 파일은 새로운 파일을 생성할 때 0으로 채우기 위해 사용
- ```/dev/tty``` : 프로그램이 실행되고 있는 터미널 윈도우 또는 콘솔
- ```/dev/dsp``` : 사운드 카드에 AU 사운드 파일을 실행하는 인터페이스
- ```/dev/fd0``` : 첫 플로피 드라이버
- ```/dev/hda1``` : IDE 하드 디스크의 첫 파티션. hda2 처럼 하나의 하드 디스크에 여러개릐 파티션을 구성할 수 있음
- ```/dev/sda1``` : SCSI, S_ATA 하드 디스크의 첫 파티션
- /dev/hda1 파티션을 /backup 디렉터리에 마운트 하려면 아래와 같이 입력
```
sudo mount -t ext3 /dev/hda1 /backup
```

## 쉘 스크립트 준비운동
- 쉘 : 키보드로부터 명령을 입력받아 OS가 그 명령을 수행하도록 하는 프로그램
- CLI, GUI를 가지고 있음
- 리눅스에서 사용할 수 있는 쉘의 종류를 확인하려면 ```/etc/shells``` 파일을 출력해보면 된다 : ```cat /etc/shells```
- Bash : 리눅스에 기본 탑재된 일반적인 쉘로 sh 본 쉘과 호환되기 때문에 대부분 sh와 bash에서 모두 작동
- ```echo``` : 뒤이어 입력되는 문자열을 모니터로 출력 (print)
- 리눅스의 모든 환경 변수는 대문자로 구성되어 있음
- ```env``` : 환경 변수 출력

### 쉘 스크립트 구성요소
- if ~ else와 fore, while 등의 쉘 루프 명령어
- grep, awk, cut 등의 텍스트 처리 유틸
- w, who, free 등의 바이너리 명령어

### 쉘 스크립트를 사용하는 이유
- 쉘 스크립트는 유저 또는 파일로부터 입력을 받아 모니터에 데이터를 출력
- 동일한 작업을 반복하여 수행하고자 할 때 자동화할 수 있다
- 시간을 절약할 수 있음
- 자신만의 파워툴, 파워 유틸리티를 만들 수 있음
- 관리자 작업을 커스터마이징 할 수 있음
- 서비스 환경 설정과 유저 추가와 같은 작업에서 에러를 줄일 수 있음
- 실제적인 쉘 스크립트 사용 예는 다음과 같음
	- 리눅스 시스템 모니터링
	- **데이터 백업과 스냅샷 생성**
	- **Oracle, MySQL 데이터베이스 백업을 위한 덤프 작업**
	- 시스템 경고메세지를 이메일로 받기
	- 시스템 리소스를 잡아먹는 프로세스 찾아내기
	- 여유 메모리와 사용량 찾아내기 
	- 로그인한 모든 유저와 현재 무엇을 하고 있는지 찾아내기
	- 네트워크 서비스가 정상적인지 아닌지 알아보기
	- 모든 실패한 로그인 정보 찾아내기
	- 보안 정책에 따른 유저 관리
	- BIND의 서버 환경에서 zone 엔트리 추가
- 쉘 스크립트를 사용하면 안될때 (프로그래밍 언어를 사용해야 할 경우)
	- 리소스에 민감한 작업들, 특히 속도가 중요한 요소일 때(정렬, 해쉬 등) 
	- 강력한 산술 연산 작업들, 특히 임의의 정밀도 연산이나 복소수를 써야할 때(C++)
	- 플랫폼 간 이식성이 필요할 때(C)
	- 구조적 프로그래밍이 필요한 복잡한 복잡한 애플리케이션
	- 업무에 아주 중요하거나 회사의 미래가 걸렸단 확신이 드는 애플리케이션
	- 보안상 중요해서 시스템 무결성을 보장하기 위해 외부의 침입이나 크래킹, 파괴 등을 막아야 할 필요가 있을 때
	- 서로 의존적인 관계에 있는 여러 컴포넌트로 이루어진 프로젝트
	- 과도한 파일 연산이 필요할 때(Bash 쉘은 제한적인 직렬적 파일 접근을 하고, 특히 불편하고 불충분한 줄 단위 접근만 가능)
	- 다차원 배열이 필요할 때
	- 링크드 리스트나 트리 같은 데이터 구조가 필요할 때
	- 그래픽이나 GUI를 만들고 변경하는 등의 작업이 필요할 때
	- 시스템 하드웨어에 직접 접근해야할 때
	- 포트나 소켓 IO가 필요할 때
	- 예전에 쓰던 코드를 사용하는 라이브러리나 인터페이스를 써야할 필요가 있을 때
	- 독점적이고 소스 공개를 안하는 애플리케이션을 만들어야 할 때
- ```man``` : 도움말 매뉴얼을 출력하는 명령어
	- 한글로 보고싶다면 ```LANG=ko_KR.UTF8```을 실행

### 리눅스 기본 명령어들의 형식
- 리눅스에서 환경 변수를 제외한 거의 모든 명령어들은 소문자로 구성되어 있으며, 윈도우와 달리 대소문자를 구분
- ```date``` 입력하면 날짜가 나오는데, ```date '+%H:%M'```을 입력하면 해당 포맷으로 변경. ```-u``` 옵션을 주면 UTC 시간이 출력

### 다중 명령어 사용
- 하나의 라인에서 여러 개의 명령을 실행하려면 하나의 명령 다음에 ```;```를 추가해 명령이 끝났음을 지정해주면 됨. 
	- 단, 첫 명령이 실패해도 두번째 명령은 반드시 실행됨
- ```&&```를 명령어 사이에 붙이면 첫 명령이 정상적으로 종료했을 경우에만 두 번째 명령을 수행함
- ```||```를 붙이면 각각의 모든 명령을 수행

### 명령 히스토리
- ```history```에 최근 실행한 명령들이 저장되어 있음
- 최근 실행한 명령을 다시 실행하기 위해 ```!```을 사용. 다음에 매칭되는 문자를 최근 명령에서 찾아서 실행
	- -1같이 마이너스 숫자를 지정할 경우 최근 명령부터 숫자만큼의 명령을 실행
- ```!!```을 사용하면 가장 최근 명령어를 다시 실행

### 리눅스 디렉터리 여행
- ```pwd``` : 현재 디렉터리 위치 보기
- ```ls``` : 파일과 디렉터리 목록 보기
	- ```ls -l```로 출력된 컬럼의 의미는 아래와 같음
	- [파일/디렉터리 퍼미션][하드 링크파일 수][소유자][그룹][파일 크기][수정 시간][파일명] 
- ```cd``` : 현재 쉘의 디렉터리 변경, 이동
- ```less```, ```more```, ```cat``` : 텍스트 파일 보기
	- less는 q를 누르면 원래 셀 위치의 다음 라인으로 돌아오고, more는 q를 누르면 원래 쉘 위치로 돌아오지 않음, cat은 쉘 프롬포트를 리턴
- ```file``` : 파일 타입 보기
- ```tree``` : 디렉터리의 트리 구조 print
	- ```-d``` : 디렉터리만 / ```-a``` : 모든 것 / ```-f``` : 파일만 / ```-L``` : 디렉터리 깊이 지정
	- ```tree -L1 /``` : 최상위 root(/) 부터 깊이가 1인 디렉터리와 파일 출력
	 
### 파일/디렉터리 퍼미션
- 파일에 대한 접근 권한을 설정하는 것으로 ```-``` 문자는 일반 파일, ```d``` 문자는 디렉터리, ```c``` 문자는 캐릭터 디바이스, ```b```는 블록 디바이스, ```l``` 은 심볼릭 링크 파일, ```s```는 소켓 파일을 의미. 그 다음 3개의 문자 단위는 파일 소유자의 read, write, execution, 그룹의 read, write, execution, 모든 사용자의 read,write,execution을 표시

### 하드 링크 파일 수
- 하드 링크 : 리눅스상에서 동일한 파일시스템 내의 파티션에서 동일한 inod 정보를 가지는 파일
- ```ln 원본파일 하드링크파일명``` 명령을 사용해 하나의 링크 파일을 생성하면 원본 파일고 ㅏ하드 링크 파일은 동일한 inode 정보를 가지게 되고, 어느 하나의 파일이 변경되면 두 파일 모두 동일한 내용과 크기로 변경
- 심볼릭 링크 : ```ln -s 원본파일 심볼릭링크파일명```을 사용하며 원본 파일의 이름만 링크. 원본 파일을 삭제하면 심볼릭 링크 파일은 가리킬 파일명이 삭제되었기 때문에 의미없는 파일이 됨	
	
### 리눅스 기본 디렉터리 구성	
- ```/``` : 루트 디렉터리
- ```/boot``` : 리눅스 커널과 부트로더가 위치하는 디렉터리
- ```/etc``` : 시스템 환경 설정 파일이 위치한 디렉터리
	- ```/etc/passwd``` : 유저의 각종 정보 저장
	- ```/etc/shadow``` : 유저 패스워드를 암호화하여 저장
	- ```/etc/fstab``` : 시스템이 부팅될 떄 참고하는 마운트할 디바이스 테이블을 저장
	- ```/etc/hosts``` : 네트워크 호스트 이름과 IP 주소
	- ```/etc/rc.d/init.d``` 또는 ```/etc/init.d``` : 부팅시 시작할 여러가지 시스템 서비스 스크립트
	- ```/etc/resolv.conf``` : 시스템에서 외부로 접속할 떄 참고할 네임서버
	- ```/etc/sysconfig/i18n``` : 부팅시 언어셋 변수와 폰트 변수를 설정
	- ```/etc/sysconfig/iptables``` : 리눅스 방화벽 iptables 환경 설정
	- ```/etc/sysconfig/network``` : 부팅시 네트워크를 지우너할 것인지와 호스트명을 설정
	- ```/etc/sysconfig/network-scripts/ifcfg-eth0``` : 부팅시 사용할 첫 이더넷 카드의 정보 저장
- ```/bin```, ```/usr/bin``` : 실행 프로그램들. ```/bin```엔 기본적인 실행 프로그램, ```/usr/bin```엔 사용자들이 사용할 실행 프로그램
- ```/sbin```, ```/usr/sbin``` : 시스템 관리자를 위한 프로그램. 대부분 root를 위한 프로그램
- ```/usr``` :  사용자 애플리케이션을 지원하기 위한 다양한 파일이 위치
- ```/usr/local``` : 소프트웨어 설치시 또는 로컬머신에서 사용할 파일들이 위치. 소스파일을 기본 옵션으로 컴파일하면 ```/usr/local``` 디렉터리에 기본 설치가 되며 이 때 실행 파일은 ```/usr/local/bin```에 위치
- ```/var``` : 운영 중인 시스템의 변화를 체크할 수 있는 로그 파일들이 위치
	- ```/var/log``` : 로그 파일이 위치하는 디렉터리
	- ```/var/spool``` : 메일 메세지와 프린트 작업과 같이 프로세스를 위한 큐를 잡아놓기 위해 사용되는 디렉터리
- ```/lib``` : 공유 라이브러리 파일
- ```/home``` : 유저별 홈디렉터리가 존재하는 개인 홈디렉터리. ```useradd(adduser)``` 명령을 사용해 유저를 생성하면 ```"/home/유저아이디``` 형식으로 유저 홈디렉터리가 생성. 이때 기본적으로 생성되는 파일들은 ```/etc/skel``` 디렉터리 아래의 파일들임
- ```/tmp``` : 임시 파일들이 저장되는 디렉터리
- ```/dev``` : 리눅스 시스템에서 사용하는 디바이스 장치 파일들
- ```/proc``` : 이 디렉터리는 파일을 포함하지 않음. 현재 시스템 CPU 정보를 출력하기 위해 ```/proc/cpuinfo``` 파일을 출력
- ```/media```, ```/mnt``` : 마운트 포인트를 위해 사용되는 디렉터리
	- 마운트 : 디바이스 장치를 사용하기 위해 프로세스와 연결하는 것
	
## 입출력 리다이렉션과 파이프
### 표준 출력
- 표준 출력 : 결과를 모니터에 출력. 파일 디스크립터 숫자값으로 1로 표기
- ```>``` 문자를 사용해 표준 출력을 파일로 리다이렉션해 저장할 수 있음
	- ```ls > ls.txt```
- ```>>``` : 파일에 추가(append)할 경우 사용
	- ```cat test1.txt >> ls.txt```
- 만약 텍스트 파일의 내용을 모두 삭제하고 싶다면 ```/dev/null```로 읽어서 파일로 리다이렉션
	- ```cat /dev/null > lsls.txt```
- 표준 입력 - 키보드 : 파일 디스크립터 숫자로 0
- 표준 출력 - 모니터 : 파일 디스크립터 숫자로 1
- 표준 에러 - 모니터 : 파일 디스크립터 숫자로 2
- ```2>&1``` : 표준 출력이 전달되는 곳으로 표준 에러를 전달하는데, 마지막에 &를 사용해 현재 명령을 백그라운드로 실행 	
### 표준 입력
- 표준 입력 : 키보드로부터 데이터를 입력받는 것. 파일 디스크립터 숫자값으로 0
- 키보드를 대신해 파일로부터 입력을 받는 경우 ```<``` 문자를 사용
- ```sort < ls.txt```
- ```sort < ls.txt > sorted_lx.tst``` : ls.txt 파일의 정렬 결과를 sorted_ls.txt 파일로 저장한 다음 결과를 sorted_ls.txt로 저장

### 파이프
- ```|``` 문자를 사용해 두 명령어를 이어줌. 앞에서 실행한 명령의 결과값을 뒤에 적은 명령어의 입력으로 사용
- 즉, 파이프로 연결된 하나의 표준 출력을 다른 명령의 표준 입력으로 사용
- ```ls -lt | head```
- ```find . -type f -print | wc -l``` : 현재 디렉터리에서 있느 파일을 출력해 출력 라운의 수를 카운트한 다음 화면에 출력되도록 한 파이프 예제
- 필터
	- 파이프에는 여러 필터를 사용할 수 있는데, 필터는 표준 입력을 받아서 이 필터로 연산을 한 다음, 그 결과를 표준 출력으로 보냄
	- sort, uniq, grep, fmt, pr, head, tail, tr, sed, awk 등

### 퍼미션
- 리눅스와 같은 멀티태스킹, 멀티유저를 지원하는 UNIX 시스템에서는 파일 및 디렉터리에 대해 퍼미션이라는 접근 권한을 사용
- ```chmod``` : 파일, 디렉터리에 대한 접근 권한 변경
	- read, write, execute 권한 지칭
	- rwx 3자리 문자는 2진수로 표시해 2^n으로 인식
	- ```rwx rwx rwx``` = 111 111 111 = 777
	- ```rw- rw- rw-``` = 110 110 110 = 666
	- ```rwx --- ---``` = 111 000 000 = 700
	- 리눅스에서 touch 또는 vi을 사용해 파일을 생성하면 기본 퍼미션이 644(rw-r--r--)로 설정됨. 기본 퍼미션은 umsk로 설정되어 있는데, 이 설정은 ```/etc/bashrc```에 설정되어 있음
- ```su``` : 일시적으로 수퍼유저 또는 다른 유저로 전환
- ```chown``` : 파일, 디렉터리의 소유자를 변경(change file owner and group)
	- chown 명령은 슈퍼 유저만 사용 가능
	- ```chown multi.multi perm.txt```
	- ```chown root:root perm.txt``` 
- ```chgrp``` : 파일, 디렉터리의 그룹 소유자 변경 
	- ```chgrp multi perm.txt```
- ```lsattr```, ```chattr``` : 파일들에 대한 특정한 속성을 부여할 수 있음
	- ```lsattr``` : 파일들의 속성을 출력
	- ```chattr``` : 파일들의 속성을 변경. ```chattr +i [파일명]```  제거의 경우엔 -를 사용
	- ```i``` : i속성은 슈퍼유저라도 변경, 삭제 등의 어떤 조작도 불가능 (immutable)
	- ```a``` : a속성은 내용 추가는 가능하지만 슈퍼 유저라도 파일 삭제는 불가능 (append only)
	
### 잡 컨트롤
- 리눅스 멀티 태스킹 : 여러 개의 프로세스를 동시에 사용하는 것
- 리눅스 커널은 동시에 실행되는 각 프로세서들을 관리할 수 있도록 구성되어 있으며, 프로세스 통제 및 관리할 수 있음
- ```ps``` : 시스템에서 실행되고 있는 프로세스 목록 보기
- ```kill``` : 프로세스에게 kill 시그널 보내기
	- 시그널 : 비동기식 이벤트 처리 메커니즘을 제공하는 소프트웨어 인터럽트
		- SIGHUP : hangup, 로그아웃 또는 접속을 종료할 떄 발생하는 시그널로 특정 프로세스가 이용하는 설정 파일을 변경시키고 변화된 내용을 곧바로 적용하고자 할 때 사용
		- SIGINT : interrupt, 현재 작동 중인 프로세스의 동작을 멈출 때 사용. <Ctrl+C>
		- SIGQUIT :quit, SIGINT와 같이 사용자가 터미널에서 종료키를 누를 때 커널에 의해 보내짐. 비정상적으로 종료하게 되므로 코어 파일을 생성하고 종료
		- SIGKILL : kill, 해당 프로세스의 실행을 강제로 중지. 가장 많이 사용되는 시그널
		- SIGSEGV : segmentation violation, 메모리 접근이 잘못되었을 떄, 즉 프로세스가 포인터를 잘못 사용하여 정해진 영역 이외의 메모리 영역을 침범했을 때 발생
		- SIGTERM : terminate, 정상적인 종료 프로세스에 정의되어 있는 정상적인 종료 방법에 의해 프로세스를 종료
	- ```kill -l``` : kill 명령으로 OS에게 보낼 수 있는 시그널 
	- ```kill %[번호]``` : jobs에 나타난 프로세스 제거
	- ```kill [PID 번호]``` : ps명령으로 출력된 프로세스 제거
- ```jobs``` : 현재 쉘에서 자신의 프로세스 목록 보기
- ```bg``` : 프로세스를 백그라운드로 보내기
- ```fg``` : 프로세스를 포그라운드로 가져오기	

## 시스템 관리자 명령어 정리
### 유저와 그룹
- ```user``` : 현재 로그인하고 있는 유저들을 출력. ```who -q```와 동일
- ```groups``` : 현재 쉘에 접속해 있는 유저가 속해 있는 그룹을 출력. ```GROUPS``` 환경 변수를 출력, 그룹 이름이 아닌 그룹 번호만 가지고 있음
- ```chown```, ```chgrp``` : 소유자, 소유자 그룹 변경
- ```useradd```, ```userdel``` : 유저를 추가, 삭제할 때 사용하는 명령
	- ```adduser``` : ```useraddd```에 심볼릭 링크되어 있음
	- 유저를 추가한 다음, ```passwd [유저 아이디]```를 통해 패스워드 지정
	- 유저를 삭제할 때, 유저 디렉터리까지 삭제하고 싶으면 ```-r``` 명령을 사용
- ```usermod```, ```groupmod``` : 그룹 이름이나 아이디 변경시 사용
- ```id``` : 유저의 아이디, 그룹아이디, 소속된 그룹명 등을 출력
- ```lid``` : 유저가 소속되어 있는 그룹 출력
- ```who``` : 현재 로그인되어 있는 유저 목록 출력
- ```w```` : 모든 유저에 대한 정보 출력. who 명령의 확장
- ```logname``` : 현재 유저의 로그인명
- ```su``` : 한 유저가 다른 유저로 전환. 유저가 주어지지 않으면 기본적으로 슈퍼 유저(root)로 설정
- ```sudo``` : 슈퍼 유저(root) 또는 다른 유저로 명령을 실행
	- ```/etc/sudoers``` 파일에 정의되어 있음
- ```passwd``` : 유저의 패스워드를 생성/변경
- ```ad``` : ```/var/log/wtmp``` 파일로부터 유저의 로그인 시간을 시간 단위로 출력
- ```last``` : ```/var/log/wtmp```로부터 모든 유저의 마지막 로그인 시간을 출력. reboot 아규먼트를 사용하면 reboot한 날짜, 시간을 출력
- ```newgrp``` : 자신이 소속된 그룹을 새 그룹으로 변경/추가하지만 현재 쉘을 빠져나오면 초기화됨	
	
### 터미널
- ```tty``` : 현재 유저의 터미널 출력 -> ```/dev/ttys000``` 라고 나옴
- ```stty``` : 터미널 설정을 출력하거나 변경할 수 있음
- ```setterm``` : 터미널의 설정갑을 변경
- ```tset``` : 터미널 설정을 초기화 하고 터미널 타입을 출력
- ```mesg``` : 다른 유저가 자신의 터미널에 접근하는 것을 제어, ```mesg y``` : 자신의 터미널에 쓰기 허용, 기본 설정. ```mesg n``` : 자신의 터미널에 쓰기 불허	
- ```wall``` : 접속해 있는 모든 유저에게 메시지를 전송할 때 사용
- ```write``` : 유저를 지정해 메시지를 발송할 경우 사용

## 정보와 통계
- ```uname``` : 커널 정보와 같은 시스템 정보를 출력해 볼 수 있음
- ```arch``` : 시스템 아키텍처를 출력. ```uname -m``` 명령과 동일
- ```lastlog``` : ```/var/log/lastlog``` 파일을 참고해 모든 유저의 마지막 로그인 시간을 출력
- ```lsof``` : 오픈된 파일의 목록을 출력. ```-i``` 옵션을 사용하면 오픈되어 있는 네트워크 소켓 파일들을 출력할 수 있음
- ```strace``` : 주어진 명령을 실행할 때 호출하는 시스템 콜과 시그널을 추적하는 명령
- ```ltrace``` : 주어진 명령을 실행할 때 호출하는 라이브러리 콜을 추적하는 명령
- ```nc``` : TCP와 UDP 포트 커넥션과 리슨을 출력. 포트 접속을 위해서는 호스트명과 포트번호를 아규먼트로 사용하면 되고, ```-z``` 옵션과 포트번호 범위를 지정하면 포트로 접속이 가능한 상태인지 체크할 수 있으며, 검색할 포트 범위는 1-80 형식을 사용함
- ```free``` : 메모리와 캐시 사용량을 Byte 단위로 출력
- ```procinfo``` : ```/proc``` 파일 시스템에 대한 정보를 출력
- ```lsdev``` : 설치된 디바이스 장치들의 목록을 출력
- ```du``` : 디스크 파일 사용량을 출력. 재귀적으로 출력하며 특정 디렉터리를 지정 가능. 
	- ```-h``` : 킬로바이트 단위로 출력 / ```-sh``` : 현재 디렉터리 아래의 전체 용량을 출력
- ```df``` : 파일시스템의 파티션 사용량을 출력.
	- ```-h``` : M, G 단위로 출력
- ```dmesg``` : 부팅 시 콘솔에 출력된 메세지들을 출력
- ```stat``` : 주어진 파일의 각종 정보를 출력
- ```vmstat``` : 버추얼 메모리 통계 출력
- ```netstat``` : 현재 네트워크 통계와 정보를 출력. 현재 오픈되어 있는 포트 목록을 출력하고자 한다면 ```-lptu``` 옵션을 사용
- ```uptime``` : 현재 시간과 시스템이 종료/재부팅되지 않고 계속 운영되고 있는 기간, 현재 접속자 수, 평균 부하를 출력. load average가 3 이상이면 시스템 성능이 현저히 떨어짐
- ```hostname``` : 시스템의 호스트명을 출력  
- ```hostid``` : 호스트 머신을 32비트 16진수 숫자의 식별자로 출력
- ```readelf``` : elf 바이너리 파일의 정보 출력
- ```size``` : 바이너리 실행 파일 또는 아카이브 파일의 세그먼트 크기를 출력

## 시스템 로그
- ```logger``` : 시스템 로그를 기록하는 명령이며, 로그는 ```/var/log/messages``` 시스템 로그 기록 파일에 저장
- ```logrotate``` : 시스템 로그 파일을 관리하기 위해 사용하며, 로테이트, 압축, 삭제, 이메일 발송 등의 기능을 사용. 일반적으로 ```cron```을 사용해 주기적으로 ```logratete```를 실행해 로그 파일을 관리. 환경 설정 파일로는 ```/etc/logrotate.conf``` 파일을 사용

## 잡 컨트롤
- ```ps``` : 현재 실행중인 프로세스 통계(PID, 프로세스 실행 시간, 실행 유저 등)를 출력. 트리 형식으로 출력하기 위해선 ```--forest``` 옵션을 사용
	- ```ps -ef``` 를 자주 사용 
- ```pgrep```, ```pkil``` : 이름 또는 다른 속성을 사용해 시그널 프로세스를 검색
- ```pstree``` : 프로세스 목록을 트리 형식으로 출력, ```-p``` 옵션을 사용하면 프로세스 아이디도 출력
- ```top``` : 전반적인 시스템 상황을 출력하며 기본값으로 3초마다 refresh
- ```nice``` : 스케줄링 우선권을 조정해 프로그램을 실행하는 명령
	- 아무런 옵션도 주어지지 않을 경우 nice는 상속받은 현재의 스케줄링 우선권을 출력
	- 조정수치가 생략되면 명령의 nice 값은 10이 됨. 음의 수치까지 부여할 수 있으며 -20 ~ 19까지 조정할 수 있음
	- ```renice``` 명령으로 실행 중인 프로세스의 우선권을 변경할 수 있으며, ```skill```, ```snice``` 명령으로 시그널을 보내거나 프로세스 상황을 리포팅 할 수 있음
	- Ss, S<, Ss+, SN 등으로 표기
- ```nohup``` : 적은 명령에 대해 Hangup(프로세스 중단) 신호를 무시한 채 수행하도록 하는 명령
	- nohup.out 파일에 출력 내용을 추가 
	- 자동으로 백그라운드로 보내지 않기 때문에 명령행 뒤에 ```&``` 문자를 추가해 실행하거나 명시적으로 백그라운드로 실행
	- 실행 파일을 백그라운드로 실행(&)하고 현재 쉘을 종료해도 실행 파일의 수행이 중단되지 않음
	- bash 쉘 옵션 중 ```huponexit```은 현재 쉘을 빠져나갈 때 SIGHUP 시그널(정지 신호)을 모든 job에게 보내는 옵션인데, 이 옵션의 기본값은 off라 현재 쉘을 종료하더라도 백그라운드로 실행된 프로세스는 종료되지 않고 계속 실행
	- ```nohup python execute.py > output &``` 등으로 사용
- ```pidof``` : 실행중인 프로세스 아이디를 검색, 출력
- ```fuser``` : 파일 또는 소켓을 사용하고 있는 프로세스를 출력
- ```cron``` : 수퍼유저용/일반유저용 스케줄러
	- ```/etc/crontab``` 파일에 설정이 존재하며, 설정별 실행할 파일들은 ```/etc/cron.hourly``` 디렉터리에 위치

## 프로세스 관리와 부팅
- ```init``` : 모든 프로세스의 부모 프로세스(PID 1번)이며 부팅시 ```/etc/inittab``` 파일에 런레벨을 결정
- ```service``` : 시스템 서비스를 시작하고 중지하기 위해 사용
	- 리눅스 시작스크립트 원본 경로는 ```/etc/rc.d/init.d``` 또는 심볼릭 링크된 ```/etc/init.d```이며, 부팅 시 7개의 런레벨별 시작 스크립트 위치는 ```/etc/rc.d``` 디렉터리 아래에 런레벨별 디렉터리 명으로 존재
	- ```service cron restart``` 등으로 사용

## 네트워크
- ```ifconfig``` :  네트워크 인터페이스 환경을 출력하고 튜닝하는 유틸리티. eth0은 첫번째 이더넷 카드를 의미하고, lo는 로컬호스트 루프백을 의미
	- ```ifconfig eht0 down``` : 네트워크 사용 중지. 시작은 up
- ```iwconfig``` : 무선랜 네트워크 인터페이스 환경을 출력해주는 명령이며, ```ifconfig```와 유사하지만 무선랜 장치만 보여줌
- ```ip``` : 라우팅, 디바이스, 라우팅과 터널 정책을 출력하고 조작할 떄 사용
- ```route``` : 커널 라우팅 테이블 정보를 출력하거나 변경. ```ip route list```와 동일한 내용 출력
- ```chkconfig``` : 시스템 서비스를 위한 런레벨 정보를 업데이트하고 검색
- ```tcpdump``` : 네트워크 패킷을 실시간으로 출력해볼 수 있음. ```tcpdump tcp port 21``` 을 실행하면 21번 포트로 통신하는 패킷들을 출력

## 파일시스템
- ```mount``` : 파일 시스템을 마운트하기 위해 사용. 파일 시스템을 가지는 디바이스는 하드 디스크의 파티션, 플로피 디스크, CDROM, USB 같은 외장 디바이스, 램디스크 등이 해당
	- ```etc/fstab``` 파일을 보면 여러 설정 내용을 볼 수 있는데, 이 설정 파일을 부팅시 자동으로 읽어들여 마운트하고 부팅 후 파일 시스템과 디바이스를 지정하지 않고 수동으로 마운트하기 위해 사용
	- ```/etc/mtab``` 파일에는 현재 마운트되어 있는 파일 시스템 또는 파티션 정보가 저장되어 있음
	- ```mount -o loop -t iso9660 -r cd_image.iso /media/cdimg```
- ```umount``` : 마운트된 파일 시스템을 즉시 마운트 해제할 때 사용. 언마운트와 동시에 시디롬 드라이브에서 시디롬을 꺼내려면 ```eject``` 명령을 사용
- ```sync``` : 업데이트된 모든 버퍼의 데이터를 강제로 하드 드라이버에 즉시 저장. 버퍼와 하드 드라이버 동기화 수행
- ```losetup``` : 루프 장치를 정규 파일 또는 블럭 장치와 연결, 루프 장치와 분리, 루프 장치의 상태 파악을 하는 데 사용됨. 루프 장치 인자만 줄 경우에 해당하는 루프 장치의 상태를 보여줌
- ```mkswap```, ```dd``` : mkswap 명령은 스왑 파일 또는 스왑 파티션을 생성할 때 사용
	- ```dd if=/dev/zero of=swapfile bs=1024 count=8192```
	- ```mkswap swapfile 8192```
	- ```sync```
	- ```swapon swapfile```
- ```swapon``` : 파일이나 파티션을 스왑으로 사용하도록 하는 명령
- ```swapoff``` : 파일이나 파티션을 스왑으로 사용하지 않도록 하는 명령
- ```mkfs.ext3``` : 파티션이나 파일을 ```ext3``` 파일 시스템으로 만들 떄 사용, ```mkfs``` 명령과 함께 ```-t``` 옵션값으로 ext3를 지정해 파일 시스템을 생성
- ```hdparam``` : 하드 디스크의 설정을 보여주거나 설정을 조정
- ```fdisk [디바이스명]``` : 저장용 디바이스의 파티션 테이븡를 생성하거나 변경
	- ```/dev/hda``` : 첫 IDE 하드 드라이브
	- ```/dev/sda``` : 첫 SATA, SCSI 하드 드라이브
- ```fsck.ext3``` : ext3 파일 시스템을 체크, 수리, 디버그하는 명령. 단 mount된 파티션에 대해 파일 시스템 체크를 하면 해당 파티션에 문제가 발생할 수 있으므로 마운트를 해제한 다음, 파일 시스템 체크를 해야함!
- ```badblocks``` : 저장 디바이스의 물리적인 배드 블록을 체크
- ```lsusb``` : 장착되어 있는 USB 디바이스 목록 출력
- ```lspci``` : 장착되어 있는 pci 디바이스 목록 출력
- ```mkbootdisk``` : 시스템 구동을 위한 독립적인 부트 플로피 디스크를 만듬. ```-iso``` 옵션을 사용해 부팅이 가능한 iso 파일로 만들 수 있음
- ```mkisofs``` : iso9660 파일 시스템, 즉 CD 이미지를 만들 수 있음
- ```chroot``` : root 디렉터리를 변경. 지정한 루트 디렉터리를 사용해 명령과 인터렉티브 쉘을 실행. 보안적 측면에서 유용함
- ```lockfile``` : procmail 패키지에 포함되어 있음. lcokfile 명령으로 세마포어 잠금 파일, 디바이스, 리소스 등을 생성해 파일 접근을 관리할 수 있음. 잠금 파일이 존재하면 다른 프로세스의 접근이 제한됨
	- ```/var/lock``` 디렉터리에 잠금 파일을 생성하고 체크하며 ```rm -f [잠금파일명]``` 명령으로 삭제할 수 있음

## 백업
- ```dump``` : 정교한 파일 시스템(ext2/ext3) 백업 유틸리티이며, -f 옵션을 사용해 네트워크 파일 시스템도 백업할 수 있음. dump 명령은 저수준 디스크 파티션을 읽고 바이너리 포맷의 백업 파일을 만듬. 이 파일들은 restore를 사용해 복원
- ```fdformat``` : 플로피 디스크를 로우레벨 저수준으로 포맷

## 시스템 리소스
- ```ulimit``` : 시스템 리소스 사용의 상한 제한값을 설정. ```-f``` 옵션을 사용해 파일 크기 제한, ```-c``` 옵션으로 코어덤프 크기를 제한, ```-a```옵션을 사용해 현재 시스템의 상한값을 출력해볼 수 있음

## 모듈
- ```lsmod``` : 설치된 커널 모듈 목록을 출력. ```cat /proc/modules```도 동일	